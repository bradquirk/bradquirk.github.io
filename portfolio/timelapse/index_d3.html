<!DOCTYPE html>
<meta charset="utf-8">
<style>
    /* set the CSS */

    body {
        font-family: 'Arial', sans-serif;
        font-size: 12px;
        font-weight: 400;
        background-color: #2E353D;
        /*        margin-top: 10px;*/
    }


    /*
.arcs {
    cursor: pointer;
}
*/

    hr {
        width: 100%;
        height: 8px;
        margin-left: auto;
        margin-right: auto;
        background-color: #FFF;
        border: 0 none;
        margin-top: 100px;
        margin-bottom: 100px;
    }

    #header {
        /*        padding: 10px 0 0 10px;*/
        font-family: "Poppins";
        color: white;
    }

    .node rect {
        cursor: move;
        fill-opacity: .9;
        shape-rendering: crispEdges;
    }

    .node text {
        pointer-events: none;
    }

    .link {
        fill: none;
        stroke: #FFF;
        stroke-opacity: .15;
    }

    .link:hover {
        stroke-opacity: .25;
    }

    #tooltip {
        background-color: rgba(0, 0, 0, .8);
        border: none;
        border-radius: 5px;
        padding: 15px;
        max-width: 400px;
        text-align: left;
        color: white;
    }

</style>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Brad Quirk | Value Stream Map</title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/mdb.min.css" rel="stylesheet">
    <link href="/css/style_lean_dashboard.css" rel="stylesheet">
    <!-- Hotjar Tracking Code for https://quirkules.github.io/ -->
    <script>
        (function(h, o, t, j, a, r) {
            h.hj = h.hj || function() {
                (h.hj.q = h.hj.q || []).push(arguments)
            };
            h._hjSettings = {
                hjid: 1230223,
                hjsv: 6
            };
            a = o.getElementsByTagName('head')[0];
            r = o.createElement('script');
            r.async = 1;
            r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
            a.appendChild(r);
        })(window, document, 'https://static.hotjar.com/c/hotjar-', '.js?sv=');

    </script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-50453785-4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-50453785-4');

    </script>

</head>

<body>
    <!-- SCRIPTS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script type="/text/javascript" src="/js/mdb.js"></script>
    <script src="/js/d3.min.js"></script>
    <script src="/js/d3-color.js"></script>
    <script src="/js/d3-scale-chromatic.js"></script>
    <script src="/js/d3-interpolate.js"></script>
    <script src="/js/jquery.js"></script>
    <script src="https://unpkg.com/d3-sankey@0"></script>
    <!-- Navbar-->
    <nav class="navbar sticky-top navbar-expand-lg navbar-dark dark-color" id="navbar">
        <a class="navbar-brand amber-text" href="/">
    <img src="/img/sitelogo_yellow.png" height="30" alt="logo"> 
  </a>
        <a class="navbar-brand amber-text" href="/">
    Brad Quirk
  </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="amber-text"><i
        class="fas fa-bars fa-1x"></i></span>
  </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item px-2">
                    <a class="nav-link amber-text" href="/">Home</a>
                </li>
                <li class="nav-item px-2 active">
                    <a class="nav-link amber-text" href="/portfolio/">Portfolio<span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item px-2">
                    <a class="nav-link amber-text" href="/about/">About</a>
                </li>
                <li class="nav-item px-2"><a class="amber-text" href="/contact/">
                    <button class="btn btn-sm btn-outline-warning" type="button">Contact</button></a>
                </li>
            </ul>
        </div>

    </nav>
    <!-- Navbar-->

    <div class="container">
        <div class="row">
            <div class="col amber-text" id="header">
                <h1>Value Stream Map</h1>
                <h6>version 1.0</h6>
            </div>
        </div>
        <div></div>
        <div class="row m-2">
            <div class="col-10" id="chart"></div>
            <div class="col-2" id="info"></div>
        </div>
        <h6 class="mb-4 white-text"><small>Note: Each checkpoint can be repositioned, and each transition contains more information when hovered over</small></h6>
        <!-- Accordion card -->
        <div class="accordion md-accordion" id="accordionValue" role="tablist" aria-multiselectable="true">
            <div>
                <!-- Card header -->
                <div class="header" role="tab" id="headingOne1">
                    <a data-toggle="collapse" data-parent="#accordionValue" href="#collapseOne1" aria-expanded="true" aria-controls="collapseOne1">
                        <h4 class="my-4 amber-text">
                            The Value <i class="fas fa-angle-down rotate-icon"></i>
                        </h4>
                    </a>
                </div>
                <!-- Card body -->
                <div id="collapseOne1" class="collapse show" role="tabpanel" aria-labelledby="headingOne1" data-parent="#accordionValue">
                    <div class="white-text">
                        <p>
                            When undertaking large-scale change programs, we want to understand our existing end-to-end processes in order to indentify more efficient avenues to add customer value, or in other words eliminate waste. The Value Stream Map (VSM) is a decades-old lean-manufacturing technique that has been used by thousands of companies to fulfil this exact purpose. Especially in agile transformation programs, it doesn't take too long until the topic of VSMs start creeping to the surface.</p>
                        <p>
                            But if we're all talking about VSMs, why aren't the outputs of the exercise sitting in a framed poster inside every boardroom or meeting hub? I believe the answer is simple; <b>traditional Value Stream Maps are really difficult to interpret.</b></p> Without a detailed workshop or instruction manual they don't hold much conveyance to the end user.

                        <p>
                            So what if we took these confusing outputs and repurposed them to make them much easier to interpret? By using the metaphor of 'flow', which is a key principle of lean manufacturing to begin with, and extending it to represent a pipeline of customer value, it should be much easier to highlight the current state of an organisation's processes and where the opportunities for improvement lie.</p>
                    </div>
                </div>

            </div>
        </div>
        <!-- Accordion card -->
        <!-- Accordion card -->
        <div class="accordion md-accordion" id="accordionHypothesis" role="tablist" aria-multiselectable="true">
            <div>
                <!-- Card header -->
                <div class="header" role="tab" id="headingOne2">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionHypothesis" href="#collapseOne2" aria-expanded="false" aria-controls="collapseOne2">
                        <h4 class="my-4 amber-text">
                            Hypothesis <i class="fas fa-angle-down rotate-icon"></i>
                        </h4>
                    </a>
                </div>
                <!-- Card body -->
                <div id="collapseOne2" class="collapse" role="tabpanel" aria-labelledby="headingOne2" data-parent="#accordionHypothesis">
                    <div class="white-text">
                        <p><i>I believe<br>
                    that by taking the existing outputs of a traditional Value Stream Map (i.e. Lead Time, Throughput, WIP, Defect & Discard Rates)<br>
                    will enable managers and leaders to easily understand and articulate the overall efficiency of their customer-driven processes<br>
                    and lead to structured conversations about optimising said processes where traditional VSMs could not before.<br>
                    I'll know I'm right when any member of an organisation can identify their place within 'the ecosystem'<br>
                    and understand how their efficincy can impact those further downstream.
                    </i></p>
                    </div>
                </div>

            </div>
        </div>
        <!-- Accordion card -->
        <!-- Accordion card -->
        <div class="accordion md-accordion" id="accordionMethod" role="tablist" aria-multiselectable="true">
            <div>
                <!-- Card header -->
                <div class="header" role="tab" id="headingOne3">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionMethod" href="#collapseOne3" aria-expanded="false" aria-controls="collapseOne3">
                        <h4 class="my-4 amber-text">
                            Method <i class="fas fa-angle-down rotate-icon"></i>
                        </h4>
                    </a>
                </div>
                <!-- Card body -->
                <div id="collapseOne3" class="collapse" role="tabpanel" aria-labelledby="headingOne3" data-parent="#accordionMethod">
                    <div class="white-text">
                        <ol>
                            <li>For the sake of producing rapid value, try to start with the most understood parts of the process</li>
                            <li>Involve those who best understand the process, which is usually those performing the work itself</li>
                            <li>Focus on the work itself, not the individuals contributing to the work</li>
                            <li>Each workshop should be long enough to involve in-depth discussion, but short enough to avoid fatigue. Typically this means each workshop is 2-4 hours in length.</li>
                            <li>Operational waste can come in different forms e.g. idling, quality control issues and discarded work.</li>
                            <li>The Value Stream Map itself will evolve significantly over time, so whiteboards and post-it notes are highly recommended.</li>
                        </ol>
                    </div>
                </div>

            </div>
        </div>
        <!-- Accordion card -->
        <!-- Accordion card -->
        <div class="accordion md-accordion" id="accordionInsights" role="tablist" aria-multiselectable="true">
            <div>
                <!-- Card header -->
                <div class="header" role="tab" id="headingOne4">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionInsights" href="#collapseOne4" aria-expanded="false" aria-controls="collapseOne4">
                        <h4 class="my-4 amber-text">
                            Insights <i class="fas fa-angle-down rotate-icon"></i>
                        </h4>
                    </a>
                </div>
                <!-- Card body -->
                <div id="collapseOne4" class="collapse" role="tabpanel" aria-labelledby="headingOne4" data-parent="#accordionInsights">
                    <div class="white-text">
                        <p>After recovering some existing Value Stream Maps created by other parties and repurposing them using the above method. I sat down with some process SMEs and A/B tested the two different outputs, with the following observations:</p>
                        <ul>
                            <li>Without instructing the user on how to interpret the 'new' visualisation method, most were able to quickly identify where the largest process bottlenecks were.</li>
                            <li>Conversely, when presented with the 'old' visualisation method that contained the same information, it took significantly longer to identify the same level of insights.</li>
                            <li>The SMEs held much more engagement with the new method, spending significantly more time evaluating the detail of each process step compared to the old method.</li>
                            <li>The majority of participants wanted to showcase the new VSM to their stakeholders as they also believed it would be a much more engaging conversation piece.</li>
                        </ul>
                    </div>
                </div>

            </div>
        </div>
        <!-- Accordion card -->
        <!-- Accordion card -->
        <div class="accordion md-accordion" id="accordionConclusion" role="tablist" aria-multiselectable="true">
            <div>
                <!-- Card header -->
                <div class="header" role="tab" id="headingOne5">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionConclusion" href="#collapseOne5" aria-expanded="false" aria-controls="collapseOne5">
                        <h4 class="my-4 amber-text">
                            Conclusion <i class="fas fa-angle-down rotate-icon"></i>
                        </h4>
                    </a>
                </div>
                <!-- Card body -->
                <div id="collapseOne5" class="collapse" role="tabpanel" aria-labelledby="headingOne5" data-parent="#accordionConclusion">
                    <div class="white-text">
                        <p>By taking the key lean principle of 'flow' and extending it to be a metaphor for how work is transformed into customer value in an interactive way, it has become easier to understand and identify opportunities to either remove waste, or otherwise optimise customer-driven processes.</p>
                    </div>
                </div>
            </div>
        </div>
        <!-- Accordion card -->
        <div class="row">
            <div class="col white-text">
                <p>If you'd like to know how this visualisation could be implemented in your organisation, feel free to <a href="/contact/" class="amber-text">contact me!</a></p>
            </div>
        </div>
    </div>

    <script>
        //        $(function() {
        //            $(this).bind("contextmenu", function(n) {
        //                n.preventDefault()
        //            })
        //        });

    </script>
    <script>
        //****** CREATE DIVS ******//

        // set the dimensions and margins of the graph
        const formatNumber = d3.format(',.0f');
        const format = d => `${formatNumber(d)} Days`;
        //const color = d3.scaleSequential().interpolator(d3.interpolateCool).domain([0, dataset.nodes.length - 1]);
        //const color = d3.scaleSequential().interpolator(piecewise(d3.interpolateHsl, ["#43B7B8", "#DE791E", "#63FD88"])).domain([0, dataset.nodes.length - 1]);
        var widthFactor, heightFactor,
            linkTable = [],
            nodeTable = [],
            links = [],
            nodes = [],
            dependencies = [],
            parseDate = d3.utcParse("%Y-%m-%dT%H:%M:%S"),
            formatDate = d3.timeFormat("%Y/%m/%d"),
            parseTime = d3.timeParse("%d/%m/%Y"),
            cleanDate = d3.timeFormat("%e %b '%y"),
            emptyDate = formatDate(parseDate(0));

        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ||
            (/Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.platform))) {
            widthFactor = 5,
                heightFactor = 1.2;
        } else {
            widthFactor = 1,
                heightFactor = 0.8;
        }
        const margin = {
                top: 100,
                right: 30,
                bottom: 20,
                left: 30
            },
            width = ($('#chart').innerWidth() * widthFactor) - margin.left - margin.right - parseFloat($('.container').css('padding-left')) - parseFloat($('.container').css('padding-right')),
            height = ($(window).innerHeight() * heightFactor) - margin.top - margin.bottom,
            nodeWidth = 100,
            nodeHeight = 40;

        const svg = d3.select("#chart")
            .append("svg")
            .style("position", "relative")
            .attr("width", width)
            .attr("height", height);

        //****** PREPARE DATA ******//

        // Get the data
        d3.csv("data.csv", function(error, data) {
            if (error) throw error;

            //create base node table using the 'target' as key
            linkTable = d3.nest()
                .key(d => formatDate(parseTime(d.date))).sortKeys(d3.ascending)
                .key(d => d.action)
                .object(data);

            //get all dates from linkTable object for reference in the loop
            dateTable = Object.keys(linkTable);

            for (entry in linkTable) {
                if (linkTable[entry].added) {
                    linkTable[entry].added.forEach(d => {
                        nodeTable.push({
                            id: d.target,
                            added: entry
                        })
                    })
                }

            }

            var color = d3.scaleSequential().interpolator(d3.interpolateRainbow).domain([0, 4]);

            var simulation = d3.forceSimulation(nodes)
                .force("charge", d3.forceManyBody().strength(d => {
                    if (d.id == "root") return -5000
                    else return -5000
                }))
                .force('collision', d3.forceCollide().radius(function(d) {
                    return 100
                }))
                .force("link", d3.forceLink(links).distance(d => {
                    if (d.source.id == "root") return 200
                    else return 200
                }))
                .force("x", d3.forceX(d => {
                    type = d.id.substr(0, d.id.indexOf('-'));
                    if (type == "root") {
                        return width / 2
                    } else return null
                }))
                .force("y", d3.forceY(d => {
                    type = d.id.substr(0, d.id.indexOf('-'));
                    if (type == "root") {
                        return height / 2
                    } else return null
                }))
                //                .force("x", d3.forceX())
                //                .force("y", d3.forceY(d => {
                //                    type = d.id.substr(0, d.id.indexOf('-'));
                //                    if (type == "root") {
                //                        return 0
                //                    } else if (type == "THEME") {
                //                        return height * 0.2
                //                    } else if (type == "FEATURE") {
                //                        return height * 0.4
                //                    } else if (type == "EPIC") {
                //                        return height * 0.6
                //                    } else if (type == "STORY") {
                //                        return height * 0.8
                //                    } else return 0
                //                }))
                .alphaTarget(1)
                .on("tick", ticked);

            var g = svg.append("g")
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
            var link = g.append("g")
                .attr("stroke", "#000")
                .attr("stroke-width", 1.5)
                .selectAll(".link");
            var dependency = g.append("g")
                .attr("stroke", "#000")
                .attr("stroke-width", 1.5)
                .selectAll(".dependency");
            var node = g.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll(".node");
            var label = g.append("g")
                .attr("font-color", "#fff")
                .attr("text-anchor", "middle")
                .attr("pointer-events", "none")
                .selectAll(".label");
            // create a tooltip
            var tooltip = d3.select("#chart")
                .append("div")
                .attr("id", "tooltip")
                .style("position", "absolute")
                .style("visibility", "hidden");

            // calculate most of the coordinates for tooltipping just once:
            var root = d3.select("svg"); // WARNING: only works when the first SVG in the page is us!
            var scr = {
                x: window.scrollX,
                y: window.scrollY,
                w: window.innerWidth,
                h: window.innerHeight
            };
            // it's jolly rotten but <body> width/height can be smaller than the SVG it's carrying inside! :-((
            var body_sel = d3.select('#chart');
            // this is browser-dependent, but screw that for now!
            var body = {
                w: body_sel.node().offsetWidth,
                h: body_sel.node().offsetHeight
            };
            var doc = {
                w: document.width,
                h: document.height
            };
            var svgpos = getNodePos(root.node());
            var dist = {
                x: 10,
                y: 10
            };
            var header = d3.select("#header").node().getBoundingClientRect();
            var navbar = d3.select("#navbar").node().getBoundingClientRect();
            var chart = $("#chart").position();

            //add drag capabilities  
            var drag_handler = d3.drag()
                .on("start", drag_start)
                .on("drag", drag_drag)
                .on("end", drag_end);

            drag_handler(node);

            //add zoom capabilities 
            var zoom_handler = d3.zoom()
                .on("zoom", zoom_actions);

            zoom_handler(svg);

            restart();

            var interval = 0;
            //the loop through each date
            var timer = d3.interval(function() {
                //create tempTable with all nodes created on the interval date
                tempTable = nodeTable.filter(d => d.added == dateTable[interval]);
                if (tempTable) {
                    tempTable.forEach(d => {
                        nodes.push(d);
                    })
                    restart();
                }

                //create tempTable with all links created on the interval date
                tempTable = linkTable[dateTable[interval]].linked;
                if (tempTable) {
                    tempTable.forEach(d => {
                        if (d.type != "dependency") {
                            links.push({
                                source: nodeTable.find(e => e.id == d.source).index.toString(),
                                target: nodeTable.find(f => f.id == d.target).index.toString(),
                                type: d.type
                            });
                        } else {
                            dependencies.push({
                                source: nodeTable.find(e => e.id == d.source).index.toString(),
                                target: nodeTable.find(f => f.id == d.target).index.toString(),
                                type: d.type
                            });
                        }
                    })
                    restart();
                }

                console.log(nodes);
                console.log(links);
                console.log(dependencies);

                //update info with the current date
                d3.select("#info")
                    .style("color", "white")
                    .html(dateTable[interval]);

                console.log(dateTable[interval]);
                //console.log(tempTable);
                interval++;

                if (interval == dateTable.length) {
                    timer.stop();
                }
            }, 1000, d3.now());


            //i think this is what we want to call every time we want to update the simulation
            function restart() {

                // Apply the general update pattern to the nodes.
                node = node.data(nodes, function(d) {
                    return d.id;
                });
                node.exit().remove();

                label = label.data(nodes, function(d) {
                    return d.id;
                });
                label.exit().remove();

                //rect nodes
                node = node.enter()
                    .append("rect")
                    .attr("fill", function(d, i) {
                        //return color(i);
                        return "grey"
                    })
                    .attr("width", nodeWidth)
                    .attr("height", nodeHeight)
                    .attr("rx", "2px")
                    .attr("ry", "2px")
                    .attr("transform", "translate(-" + nodeWidth / 2 + ",-" + nodeHeight / 2 + ")")
                    .merge(node)
                    .on("mouseover", function() {
                        return tooltip.style("visibility", "visible");
                    })
                    .on("mousemove", function(d, i) {
                        //determine defect/discard text colours
                        //                        var defectColour, discardColour;
                        //
                        //                        defectColour = d.defectRate > 0.4 ? "red" : "white";
                        //                        discardColour = d.discardRate > 0.2 ? "red" : "white";

                        var m = d3.mouse(root.node());
                        scr.x = window.scrollX;
                        scr.y = window.scrollY;
                        m[0] += svgpos.x;
                        m[1] += svgpos.y;
                        tooltip.style("right", "");
                        tooltip.style("left", "");
                        tooltip.style("bottom", "");
                        tooltip.style("top", "");
                        tooltip.html(d.id + "<br>Completion %:");
                        if (m[0] > scr.x + scr.w / 2) {
                            tooltip.style("right", (body.w - m[0] + dist.x) + margin.right + "px");
                        } else {
                            tooltip.style("left", (m[0] + dist.x) + margin.left - chart.left + "px");
                        }

                        if (m[1] > scr.y + scr.h / 2) {
                            tooltip.style("bottom", (body.h - m[1] + dist.y) + header.height + navbar.height + "px");
                        } else {
                            tooltip.style("top", (m[1] + dist.y) - header.height - navbar.height + "px");
                        }
                        tooltip.style("visibility", "visible");
                    })
                    .on("mouseout", function() {
                        return tooltip.style("visibility", "hidden");
                    })
                    .call(drag_handler);

                label = label.enter()
                    .append("text")
                    .attr("dx", 12)
                    .attr("dy", ".35em")
                    .attr("transform", "translate(-" + ((nodeWidth / 4) - 7.5) + ",0)")
                    .text(function(d) {
                        return d.id
                    })
                    .merge(label);

                // Apply the general update pattern to the links.
                link = link.data(links, function(d) {
                    return d.source.id + "-" + d.target.id;
                });
                link.exit().remove();

                link = link.enter()
                    .append("line")
                    .attr("stroke", function(d, i) {
                        type = nodes[d.source].id.substr(0, nodes[d.source].id.indexOf('-'));
                        if (d.source == 0) {
                            return color(0)
                        } else if (type == "THEME") {
                            return color(1)
                        } else if (type == "FEATURE") {
                            return color(2)
                        } else if (type == "EPIC") {
                            return color(3)
                        }
                    })
                    .merge(link);

                // Apply the general update pattern to the dependencies.
                dependency = dependency.data(dependencies, function(d) {
                    return d.source.id + "-" + d.target.id;
                });
                dependency.exit().remove();

                dependency = dependency.enter()
                    .append("line")
                    .attr("stroke", "red")
                    .attr("x1", width / 2)
                    .attr("x2", width / 2 + 100)
                    .attr("y1", height / 2)
                    .attr("y2", height / 2 + height)
                    .merge(dependency);

                // Update and restart the simulation.
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();
            }

            function ticked() {
                node.attr("x", function(d) {
                        return d.x;
                    })
                    .attr("y", function(d) {
                        return d.y;
                    })

                label.attr("x", function(d) {
                        return d.x;
                    })
                    .attr("y", function(d) {
                        return d.y;
                    })

                link.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });

                dependency.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });
            }

            function drag_start(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            //make sure you can't drag the circle outside the box
            function drag_drag(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function drag_end(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            //Zoom functions 
            function zoom_actions() {
                g.attr("transform", d3.event.transform)
            }

            function getNodePos(el) {
                var body = d3.select('body').node();

                for (var lx = 0, ly = 0; el != null && el != body; lx += (el.offsetLeft || el.clientLeft), ly += (el.offsetTop || el.clientTop), el = (el.offsetParent || el.parentNode))
                ;
                return {
                    x: lx,
                    y: ly
                };
            }
        })

    </script>
</body>
