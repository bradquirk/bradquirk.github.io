d3.csv("data.csv").then(function(e) { var t = { xAxis: "white", releaseLine: "white", mouseoverSelectedNode: "#00FFFF", mouseoverConnectedNode: "#00FFA1", mouseoverUnconnectedNode: "#FBB03B", nodeColour: "#2E2E2E", nodeOpacity: .2, nodeSelectedOpacity: .2, nodeUnselectedOpacity: .1, linkOpacity: .7, linkSelectedOpacity: 1, linkUnselectedOpacity: .1 },
        a = d3.utcParse("%Y-%m-%dT%H:%M:%S"),
        r = d3.timeFormat("%Y-%m-%d"),
        n = (d3.timeFormat("%d-%m-%Y"), d3.timeParse("%Y-%m-%d")),
        o = r(a(0));
    e.forEach(function(e) { e.key = e.Key, e.inProgressDate = r(a(e["First In Progress Date"])), e.resolvedDate = r(a(e["Last Resolved Date"])) }); var s = d3.nest().key(e => e.inProgressDate).sortKeys(d3.ascending).key(e => e.resolvedDate).sortKeys(d3.ascending).rollup(e => e.length).entries(e);
    s.forEach((e, t) => { if (e.key != o) { for (var a = 0; a < e.values.length; a++) e.values[a].key != o && (e.source = n(e.key), e.target = n(e.values[a].key), e.count = e.values[a].value);
            delete e.key, delete e.values } }); var l = d3.nest().key(e => e.resolvedDate).sortKeys(d3.ascending).rollup(e => e.length).entries(e),
        d = 0;
    l.forEach((e, t) => { e.key == o ? l.shift() : e.key = n(e.key), 0 == t ? d = e.value : d += e.value, e.cfd = d }); var c = l;
    c.sort((e, t) => d3.ascending(e.key, t.key)), c = c.filter(e => r(e.key) != o); var i = $("#cycleChart").width() - 40 - 40,
        y = .3 * $(window).innerHeight() - 20 - 40,
        u = d3.select("#cycleChart").append("svg").attr("width", i + 40 + 40).attr("height", y + 20 + 40).append("g").attr("transform", "translate(40,20)");
    u.append("text").attr("id", "wew").attr("text-anchor", "middle").attr("transform", "translate(" + i / 2 + ",0)").attr("dy", "0.35em").text("Lifecyle (Cycle Time) of Each Release"); var p = d3.scaleTime().range([0, i]),
        g = d3.scaleLinear().range([y, 0]);
    p.domain([d3.min(s, e => e.source), d3.max(s, e => e.target)]), g.domain([0, d3.max(s, e => e.count)]); var k = d3.scaleLinear().domain(d3.extent(c, e => e.value)).range([5, 15]),
        v = d3.scaleSequential().interpolator(piecewise(d3.interpolateHcl, ["#D19E1F", "#CC3B43"])).domain(d3.extent(s, e => p(e.target) - p(e.source))),
        f = d3.scaleSequential().interpolator(piecewise(d3.interpolateHcl, ["#6D469D", "#37B96A"])).domain(d3.extent(c, (e, t) => t));
    console.log(f.domain()); var m = d3.scaleLinear().domain(d3.extent(s, e => p(e.target) - p(e.source))).range(["#00FFFF", "#00FFA1"]),
        h = d3.scaleLinear().domain(d3.extent(s, e => e.count)).range([2, 5]),
        x = d3.arc().innerRadius(e => (p(e.target) - p(e.source)) / 2 - h(e.count)).outerRadius(e => (p(e.target) - p(e.source)) / 2),
        N = d3.arc().innerRadius(e => 0).outerRadius(e => k(e.value)),
        w = u.append("g").selectAll("path").data(s).enter().append("path").attr("class", "arc").attr("id", e => "inProgress_" + r(e.source) + "_" + r(e.target)).attr("source", e => r(e.source)).attr("target", e => r(e.target)).attr("transform", e => "translate(" + (p(e.target) - (p(e.target) - p(e.source)) / 2) + "," + y + ")").style("fill", e => v(p(e.target) - p(e.source))).style("opacity", t.linkOpacity).attr("d", x.startAngle(1.5 * Math.PI).endAngle(2.5 * Math.PI)).on("mouseover", e => { R.style("stroke", function(a) { return r(a.key) === r(e.target) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(t.key) === r(e.target) ? 1 : 0 }), P.style("fill", function(a) { return r(a.key) === r(e.target) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(t.key) === r(e.target) ? 1 : 0 }), D.style("fill", function(a) { return r(a.key) === r(e.target) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(t.key) === r(e.target) ? 1 : 0 }), F.style("fill", function(t) { return r(t.source) === r(e.source) && r(t.target) === r(e.target) ? m(p(t.target) - p(t.source)) : v(p(t.target) - p(t.source)) }).style("opacity", function(t) { return r(t.source) === r(e.source) && r(t.target) === r(e.target) ? 1 : 0 }) }).on("mouseout", e => { resetDefault() }),
        A = {};
    s.forEach(function(e) { A[r(e.source) + "," + r(e.target)] = e.count }), u.append("g").attr("id", "x").attr("class", "axis").attr("transform", "translate(0," + y + ")").style("pointer-events", "none").call(d3.axisBottom(p)); var C = u.append("g").selectAll("path").data(c).enter().append("path").attr("class", "nodes").attr("id", e => "node" + r(e.key)).attr("transform", e => "translate(" + p(e.key) + "," + y + ")").attr("d", N.startAngle(1.5 * Math.PI).endAngle(2.5 * Math.PI)).style("fill", (e, t) => f(t)).attr("stroke", t.nodeColour).on("mouseover", e => nodeMouseover(e)).on("mouseout", e => resetDefault()),
        F = u.append("g").selectAll("path").data(s).enter().append("path").attr("class", "arc").attr("id", e => "inProgress_" + r(e.source) + "_" + r(e.target)).attr("source", e => r(e.source)).attr("target", e => r(e.target)).attr("transform", e => "translate(" + (p(e.target) - (p(e.target) - p(e.source)) / 2) + "," + y + ")").style("pointer-events", "none").style("opacity", 0).attr("d", x.startAngle(1.5 * Math.PI).endAngle(2.5 * Math.PI)),
        D = u.append("g").selectAll("circle").data(c).enter().append("circle").attr("class", "nodeHighlight").attr("id", e => "node" + r(e.key)).attr("transform", e => "translate(" + p(e.key) + "," + y + ")").attr("r", e => k(e.value)).style("pointer-events", "none").style("stroke", "black").style("stroke-width", .25).style("opacity", 0);
    d3.selectAll("#node0NaN-NaN-NaN").remove(), d3.selectAll("#node0NaN-NaN").remove(), d3.selectAll("#node0NaN").remove(); var L = d3.select("#releaseChart").append("svg").attr("width", i + 40 + 40).attr("height", y + 20 + 40).append("g").attr("transform", "translate(40,20)");
    L.append("text").attr("id", "wew").attr("text-anchor", "middle").attr("transform", "translate(" + i / 2 + ",0)").attr("dy", "0.35em").text("Cumulative Releases (Throughput) Over Time"); var M = d3.scaleLinear().domain([0, c[c.length - 1].cfd]).range([y, 0]);
    L.append("g").attr("id", "x").attr("class", "axis").attr("transform", "translate(0," + y + ")").style("pointer-events", "none").call(d3.axisBottom(p)), L.append("g").attr("id", "y").attr("class", "axis").style("pointer-events", "none").call(d3.axisLeft(M)), c.forEach((e, t) => { 0 == t ? L.append("line").attr("class", "cfdLine").attr("x1", p.domain()[0]).attr("y1", M(0)).attr("x2", p(e.key)).attr("y2", M(e.cfd)).attr("stroke-width", "2px").attr("stroke", f(t)) : L.append("line").attr("class", "cfdLine").attr("x1", p(c[t - 1].key)).attr("y1", M(c[t - 1].cfd)).attr("x2", p(e.key)).attr("y2", M(e.cfd)).attr("stroke-width", "2px").attr("stroke", f(t)) }), L.append("g").selectAll("line").data(c).enter().append("line").attr("class", "releaseLine").attr("x1", e => p(e.key)).attr("y1", e => M(0)).attr("x2", e => p(e.key)).attr("y2", e => M(e.cfd) + k(e.value)).attr("stroke-width", "1px").attr("stroke-dasharray", "2 2").style("opacity", t.nodeOpacity).attr("stroke", t.releaseLine).on("mouseover", e => nodeMouseover(e)).on("mouseout", e => resetDefault()), L.append("g").selectAll("circle").data(c).enter().append("circle").attr("class", "nodes").attr("id", e => "node" + r(e.key)).attr("cx", e => p(e.key)).attr("cy", e => M(e.cfd)).attr("r", e => k(e.value)).style("fill", (e, t) => f(t)).attr("stroke", t.nodeColour).attr("stroke-width", "1px").on("mouseover", e => nodeMouseover(e)).on("mouseout", e => { resetDefault() }); var P = L.append("g").selectAll("circle").data(c).enter().append("circle").attr("class", "nodeHighlight").attr("id", e => "node" + r(e.key)).attr("cx", e => p(e.key)).attr("cy", e => M(e.cfd)).attr("r", e => k(e.value)).style("pointer-events", "none").style("stroke", "black").style("stroke-width", .25).style("opacity", 0),
        R = L.append("g").selectAll("line").data(c).enter().append("line").attr("class", "releaseLine").attr("x1", e => p(e.key)).attr("y1", e => M(0)).attr("x2", e => p(e.key)).attr("y2", e => M(e.cfd) + k(e.value)).style("pointer-events", "none").style("stroke", "black").style("stroke-width", .25).style("opacity", 0);

    function isReleasedConnected(e, t) { return A[r(t.key) + "," + r(e.key)] || r(e.key) == r(t.key) }

    function nodeMouseover(e) { d3.select("#node" + r(e.key)).style("fill", t.mouseoverSelectedNode), R.style("stroke", function(a) { return r(e.key) === r(a.key) ? t.mouseoverSelectedNode : isReleasedConnected(e, a) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(e.key) === r(t.key) ? 1 : 0 }), P.style("fill", function(a) { return r(e.key) === r(a.key) ? t.mouseoverSelectedNode : isReleasedConnected(e, a) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(e.key) === r(t.key) ? 1 : 0 }), D.style("fill", function(a) { return r(e.key) === r(a.key) ? t.mouseoverSelectedNode : isReleasedConnected(e, a) ? t.mouseoverConnectedNode : t.mouseoverUnconnectedNode }).style("opacity", function(t) { return r(e.key) === r(t.key) ? 1 : 0 }), F.style("fill", function(t) { return r(t.target) === r(e.key) || r(t.source) === r(e.key) ? m(p(t.target) - p(t.source)) : v(p(t.target) - p(t.source)) }).style("opacity", function(t) { return r(t.target) === r(e.key) ? 1 : 0 }) }

    function resetDefault() { C.style("fill", (e, t) => f(t)).attr("stroke", t.nodeColour), R.style("opacity", 0), P.style("opacity", 0), D.style("opacity", 0), w.style("fill", e => v(p(e.target) - p(e.source))).style("opacity", t.linkOpacity), F.style("opacity", 0) }

    function piecewise(e, t) { for (var a = 0, r = t.length - 1, n = t[0], o = new Array(r < 0 ? 0 : r); a < r;) o[a] = e(n, n = t[++a]); return function(e) { var t = Math.max(0, Math.min(r - 1, Math.floor(e *= r))); return o[t](e - t) } } });